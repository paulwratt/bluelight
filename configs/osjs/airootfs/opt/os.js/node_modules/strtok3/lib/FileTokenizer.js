"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AbstractTokenizer_1 = require("./AbstractTokenizer");
const type_1 = require("./type");
const FsPromise_1 = require("./FsPromise");
class FileTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
    constructor(fd, fileSize) {
        super();
        this.fd = fd;
        this.fileSize = fileSize;
        this.fs = new FsPromise_1.FsPromise();
    }
    /**
     * Read buffer from file
     * @param buffer
     * @param offset is the offset in the buffer to start writing at; if not provided, start at 0
     * @param length is an integer specifying the number of bytes to read, of not provided the buffer length will be used
     * @param position is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.
     * @returns Promise number of bytes read
     */
    readBuffer(buffer, offset = 0, length = buffer.length, position) {
        if (position) {
            this.position = position;
        }
        if (length === 0) {
            return Promise.resolve(0);
        }
        if (!length) {
            length = buffer.length;
        }
        return this.fs.read(this.fd, buffer, offset, length, this.position).then(res => {
            if (res.bytesRead < length)
                throw new Error(type_1.endOfFile);
            this.position += res.bytesRead;
            if (res.bytesRead < length) {
                throw new Error(type_1.endOfFile);
            }
            return res.bytesRead;
        });
    }
    /**
     * Peek buffer from file
     * @param buffer
     * @param offset is the offset in the buffer to start writing at; if not provided, start at 0
     * @param length is an int
     * eger specifying the number of bytes to read, of not provided the buffer length will be used
     * @param position is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.
     * @returns Promise number of bytes read
     */
    peekBuffer(buffer, offset = 0, length = buffer.length, position = this.position, maybeLess = false) {
        return this.fs.read(this.fd, buffer, offset, length, position).then(res => {
            if (!maybeLess && res.bytesRead < length) {
                throw new Error(type_1.endOfFile);
            }
            return res.bytesRead;
        });
    }
    /**
     * @param length Number of bytes to ignore
     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
     */
    ignore(length) {
        const bytesLeft = this.fileSize - this.position;
        if (length <= bytesLeft) {
            this.position += length;
            return Promise.resolve(length);
        }
        else {
            this.position += bytesLeft;
            return Promise.resolve(bytesLeft);
        }
    }
    close() {
        return this.fs.close(this.fd);
    }
}
exports.FileTokenizer = FileTokenizer;
