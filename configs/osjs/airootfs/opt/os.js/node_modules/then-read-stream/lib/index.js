"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
class Deferred {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.reject = reject;
            this.resolve = resolve;
        });
    }
}
/**
 * Error message
 */
exports.endOfStream = "End-Of-Stream";
class StreamReader {
    constructor(s) {
        this.s = s;
        this.endOfStream = false;
        /**
         * Store peeked data
         * @type {Array}
         */
        this.peekQueue = [];
        if (!s.read || !s.once) {
            throw new Error("Expected an instance of stream.Readable");
        }
        this.s.once("end", () => {
            this.endOfStream = true;
            if (this.request) {
                this.request.deferred.reject(new Error(exports.endOfStream));
                this.request = null;
            }
        });
    }
    /**
     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
     * @param buffer Buffer to store data read from stream in
     * @param offset Offset buffer
     * @param length Number of bytes to read
     * @param position Source offset
     * @returns {any}
     */
    peek(buffer, offset, length) {
        return this.read(buffer, offset, length).then(bytesRead => {
            this.peekQueue.unshift(buffer.slice(offset, bytesRead));
            return bytesRead;
        });
    }
    /**
     * Read chunk from stream
     * @param buffer Target buffer to store data read from stream in
     * @param offset Offset of target buffer
     * @param length Number of bytes to read
     * @returns {any}
     */
    read(buffer, offset, length) {
        if (length === 0) {
            return Promise.resolve(0);
        }
        if (this.peekQueue.length > 0) {
            const peekData = this.peekQueue.shift();
            if (length <= peekData.length) {
                peekData.copy(buffer, offset, 0, length);
                if (length < peekData.length) {
                    this.peekQueue.unshift(peekData.slice(length));
                }
                return Promise.resolve(length);
            }
            else {
                peekData.copy(buffer, offset);
                return this.read(buffer, offset + peekData.length, length - peekData.length).then(bytesRead => {
                    return peekData.length + bytesRead;
                }).catch(err => {
                    if (err.message === exports.endOfStream) {
                        return peekData.length; // Return partial read
                    }
                    else
                        throw err;
                });
            }
        }
        else {
            return this._read(buffer, offset, length);
        }
    }
    /**
     * Read chunk from stream
     * @param buffer Buffer to store data read from stream in
     * @param offset Offset buffer
     * @param length Number of bytes to read
     * @returns {any}
     */
    _read(buffer, offset, length) {
        assert.ok(!this.request, "Concurrent read operation?");
        if (this.endOfStream) {
            return Promise.reject(new Error(exports.endOfStream));
        }
        const readBuffer = this.s.read(length);
        if (readBuffer) {
            readBuffer.copy(buffer, offset);
            return Promise.resolve(readBuffer.length);
        }
        else {
            this.request = {
                buffer,
                offset,
                length,
                deferred: new Deferred()
            };
            this.s.once("readable", () => {
                this.tryRead();
            });
            return this.request.deferred.promise.then(n => {
                this.request = null;
                return n;
            }).catch(err => {
                this.request = null;
                throw err;
            });
        }
    }
    tryRead() {
        const readBuffer = this.s.read(this.request.length);
        if (readBuffer) {
            readBuffer.copy(this.request.buffer, this.request.offset);
            this.request.deferred.resolve(readBuffer.length);
        }
        else {
            this.s.once("readable", () => {
                this.tryRead();
            });
        }
    }
}
exports.StreamReader = StreamReader;
